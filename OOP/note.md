# 写在前面的话
- 推荐图书- 【python编程从入门到实践】
- 邮箱
    - 我们会交给大家用python发送邮件
    - 对邮件进行设置，只要设置好了，通过邮箱地址和授权码就能发送邮件了
    
# 其他、 anaconda基本使用
- anaconda主要是一个虚拟环境管理器
- 还是一个安装包管理器
- conda list： 显示anaconda安装的包
- conda env list: 显示anaconda的虚拟环境列表
- conda create -n xxx python=3.6: 创建一个python3.6的环境，名称为 xxx

# 0. OOP-Python面向对象
- python的面向对象
- 面向对象编程
    - 基础
    - 公有私有
    - 继承
    - 组合、Minxi
- 魔法函数
    - 魔法函数概述
    - 构造类魔法函数
    - 运算类魔法函数
    
# 一、面向对象概述 （ObjectOriented. OO）

- OOP
    - OO：面向对象
    - OOA：面向对象分析
    - OOD：面向对象设计
    - OOI：面向对象的实现
    - OOP：面向对象的设计
    - OOA -> OOD -> OOI:面向对象的实现过程
    
    
    
# 二、 类和对象的概念

- 类： 抽象名词：代表一个集合、共性的事物
    - 对象的所有成员
        obj.__dict__
        
    - 类的所有成员
        class_name.__dict__
    
    - 类和对象的成员分析
        - 类和对象都可以存储成员，成员可以归所有类所有，也可以归对象所有
        - 类存储成员时，使用的时与类关联的一个对象
        - 对象存储成员时存储当前对象中
        - !!!注意!!!(和C++不同，类实例有自己的存储空间)：类实例和对象实例都有自己的存储空间，存储自己的数据
        - 访问一个对象成员时，若对象成员发生了变化，则访问对象成员
            若对象成员没有发生变化，则可以访问类成员,因为没有对成员变量赋值操作时，其成员变量和类成员变量使用的是同一份内存

    - 创建对象的时候，类的成员不会放入对象当中，而是得到一个空对象，没有成员
    
    - 通过对象对类中成员重新赋值，或通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员
   

# 三、关于self
- 类似于C++中的this，但不是
- self在对象的方法中表示当前对象本身，如果通过对象调用一个方法，那该对象会自动传入到当前方法的第一个参数里
- 方法中有self形参的方法成为非绑定类的方法，可以通过对象访问，没有self的是绑定类的方法，只能通过类
- 使用类访问绑定类方法时，如果类方法中需要访问当前类成员，可以通过__class__成员名来访问

- （个人理解：python中定义的class是一个元对象，可以理解为C++中一个已经实例化的对象，其他对象时通过拷贝此对象进行实例化的）
    
# 四、面向对象的三大特性
- 封装
- 继承
- 多态

## 4.1 封装
- 封装就是对对象成员进行访问限制
- 封装的三个级别
    - 公开： public
    - 受保护的：protected
    - 私有的：private
    - 注意(和C++不同)：public、protected、private都不是关键字
    
- 判别对象的位置
    - 对象内部
    - 对象外部
    - 子类中
    
- 
    
- 私有
    - 在成员前面添加两个下划线即可
    
            class Person():
                # name是共有的成员
                name = "liuying"
                # __age就是私有成员
                __age = 18
    
    - python的私有不是真私有，是一种称为name mangling的改名策略
      可以使用对象名_classname_attribute
      
      
- 受保护的封装 protected
    - 受保护的封装是将对象成员进行一定级别的封装，然后，在类中或者子类中都可以进行访问，但外部不能访问。
    - 封装方法： 在成员名称前加一个下划线即可

- 公开的，公共的：public
    - 公共的封装实际对成员没有访问限制，任何地方都能访问
    
## 4.2 继承
- 继承就是一个类可以获得另外一个类的成员属性或者成员方法
- 作用：减少代码，增加代码的复用功能，同时可以设置类与类的直接关系
- 继承与被继承的概念：
    - 被继承的类叫父类，也叫基类，也叫超类
    - 用于继承的类叫子类，也叫派生类
    - 继承与被继承的关系一定存在一个 is-a 关系
    
- 继承的语法，参见03.python

- 继承的特征
    - 所有的类都继承自object类（与C++不同）
    - 子类一旦继承父类，则可以使用父类除私有成员外的所有内容
    - 子类继承父类后并没有将父类成员完全赋值到子类中，而是通过引用关系访问调用？？？
    - 子类中可以定义独有的成员属性和方法
    - 子类中定义的成员和父类成员如果相同，则优先使用子类成员
    - 子类如果想扩展父类方法，可以在定义新方法的同时访问父类成员来进行代码重用
        可以使用：父类名.父类成员 的格式来调用父类成员，也可以使用 super().父类成员 的格式来调用
  
- 构造函数
    - 是一类特殊的函数，在类的实例化之前调用
    
- super
    - super不是关键字，而是一个类
            
            print(type(super))  
            
    - super的作用是获取MRO（MethondResolustionOrder）列表中的第一个类
    - super与父类没有直接实质性的关系，但通过super可以调用父类方法
    - super的两个用法
        - 参见构造函数调用父类构造函数
        
    - 查看一个类的继承关系：print(class_name.__mro__)
    
    
- 菱形继承/钻石继承问题
    - 多个子类继承自同一个父类，这些子类又被同一个类继承， 于是继承关系图形形成了一个菱形图谱。
    - 关于多继承的MRO（Method Resolution Order）
        - MRO就是多继承中，用于保存继承顺序的一个列表
        - python本身采用C3算法来对多继承继承关系进行计算
        - MRO列表计算原则
            - 子类永远在父类前面
            - 如果多个父类，则根据继承语法中括号内的书写顺序存放
            - 如果多个类继承了同一个父类，子孙类中只会选取继承语法括号中第一个父类的父类
    

 
- 有继承关系时，构造函数调用与C++的区别：
    - Python实例化一个对象时，应该是按照MRO表查找构造函数，若找到了构造一个构造函数就执行它，不会继续向父类查找
    - 所以如果要调用基类的所有构造函数，需要手动调用 class_name.__init__(self,...)
## 4.3 多态
- 多态就是一个对象在不同情况下有不同状态出现
- 多态不是语法是一种设计思想
- 多态性：一种调用防止，不同的执行效果
- 多态： 同一事物的多种形态，比如动物分人类、狗类、猪类


- Mixin设计模式
    - 主要是采用多继承的方式对类进行扩展
    - 上网自己查一下
    
- 我们使用多继承语法来实现Mixin
- 使用Mixin实现多继承的时候非常小心
    - 首先他必须表示某一单一的功能，而不是某个物品
    - 职责必须单一，如果由多个功能，则写成多个Mixin
    - Mixin不能依赖于子类的实现
    - 子类即使没有继承这个Mixin类，也能照样工作，只是缺少了某个功能
    
- 优点
    - 使用Mixin可以在不对类进行任何修改的情况下，扩展功能
    - 可以方便的组织和维护不同功能组件的划分
    - 可以根据需要任意调整功能类的组合
    - 可以避免创建很多的新的类，导致类的继承混乱
    
## issubclass 判断是否为子类
        class B(A):
            pass
            
        issubclass(B,A) #, B 是否是A的子类

## isinstance 是否是类的一个实例： 

        a = A()
        isinstance(a,A)
        
        
## hasattr 是否为类的属性
- getattr：获取
- setattr：设置
- delattr：删除
- dir：获取对象的成员列表

- 注意：可以使用help(setattr) 查看如何使用

        class A():
            name = 'noname'
            
        a = A()
        print(hasattr(a, "name")) # 返回true
        print(hasattr(a, "age"))  # 返回false
        
        
# 5. 类的成员描述符（属性）
- 类的成员描述符是为了在类的成员属性进行相关操作而创建的一种方式
    - get: 获取属性操作
    - set：修改或添加属性操作
    - delete： 删除属性操作
    
- 如果想使用类的成员描述符，大概有三种方法
    - 使用类实现描述器 （使用不多）
    - 使用属性修饰符   （使用不多）
    - 使用property函数 ( 视频只讲了这个 )
        - property函数很简单
        - property(fget, fset, fdel, doc)
        - 案例：看property案例.py
        
- 无论哪种修饰符，都是为了对成员属性进行相应的控制
    - 类的方式：适合多个类中的多个属性共用用一个描述符
    - property：适用当前类中适用，可以控制一个类中多个属性
    - 属性描述符：适用于当前类适用，控制一个类中的一个属性
    
# 6. 类的内置属性

        __dict__ :以字典方式及显示类的成员组成
        __doc__ :获取类的文档信息
        __name__ :获取类的名称 
        __bases__ : 以元组方式显示类的所有父类
        
        
# 7. 类的常用魔术方法
- 魔术方法就是不需要人为调用，基本在特定是时刻自动触发
- 魔术方法有一个统一的特征：方法名被前后两个下划线包裹
- 操作类
    - '__init__':构造函数
    - '__new__' : 对象实例化方法，一个对象初始化先调用new，后调用init构造函数（一般不要用）
    - '__call__' : 对象当函数使用的时候触发
            
            问题： 什么使用对象当函数使用？？？？
                
    - '__str__' : 当对象被当做字符串使用的时调用
    - '__repr__' : 返回字符串，跟__str__差不多，***可百度区别***
- 描述符相关
    - '__set__':
    - '__get__' : 
    - '__delete__' : 
- 属相操作相关
    - '__getattr__':访问一个不存在的属性是触发
    - '__setattr__' :对成员属性进行设置的时候触发
        - 参数： 
            - self用来取当前对象
            - 被设置的属性名称，以字符串形式出现
            - 需要对属性名称设置的值
        - 作用： 进行属性设置的使用进行验证或者修改
        - 注意： 在该方法中不能对属性直接进行赋值操作，否则进入死循环
        
- 运算分类相关魔术方法
    - '__gt__' : 进行大于判断的时候触发
        - 参数： 
            - self
            - 第二个参数是第二个对象
            - 返回值可以返回任意值，推荐返回布尔值
            - 案例
            
# 8. 类和对象的三种方法
- 实例方法
    - 需要实例化对象才能使用的方法，使用过程可能需要截止对象的其他对象方法完成
- 静态类方法
    - 不需要实例化，通过类直接访问   
- 类方法
    - 不需要实例化，
- 参考案例

- 作业： 自行查找三种方法内存使用方面的区别


# 9. 类成员描述符
- 变量的三种用法
- 类属性 property三种操作
    - 除了普通的三种操作，还想增加点其他的操作，那么可以使用property完成
    
# 10. 抽象类
- 抽象方法：没有具体实现内容的方法称为抽象方法
- 抽象方法的主要意义是规范子类的行为和接口
- 抽象类的使用需要借助abc模块

        import abc
        
- 抽象类： 包含抽象方法的类叫抽象类
- 抽象类的使用
    - 抽象类可以包含抽象类方法，也可以包含普通方法
    - 抽象类中可以有方法也可以有属性
    - 抽象类无法直接实例化
    - 子类继承才可以使用，继承的子类必须实现所有继承来的抽象方法
    - 假定子类没有实现所有继承的抽象方法，则子类不能实例化
    - 抽象类的主要作用是设定类的标准，以便于开发的时候具有统一性
    
    
# 11. 自定义类
- 类其实是一个类定义和各种方法的自由组合
- 可以定义类和函数，然后自己通过类直接赋值
- 借助type实现
- 利用元类- MetaClass
    - 元类是类
    - 可以用来创建别的类
    
 
 
 
 
